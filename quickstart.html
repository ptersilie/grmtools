<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quickstart Guide - grmtools</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="quickstart.html" class="active"><strong aria-hidden="true">1.</strong> Quickstart Guide</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">grmtools</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#quickstart-guide" id="quickstart-guide"><h1>Quickstart Guide</h1></a>
<p>This is a short guide to get you started with lrpar and shows how to generate a
standalone parser from a given grammar. lrpar is meant to be used as a
replacement for the parser generator
<a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>, and thus uses the same syntax
wherever possible. The main difference is the grammar actions which, unlike
Yacc, need to be written in Rust. Similar to Yacc, we need to define both
lexing and parsing rules. The lexing rules are used to tokenise the user input
which are then handed over to the parser. The parser then generates a parse
tree according to the parsing rules, or alternatively executes the grammar
actions. In this example we will use lrlex to define our lexing rules as
regular expressions. However, the lexer is completely interchangeable and can
be replaced with a more sophisticated version if needed. For more information
and detailed explanations please refer to the <a href="tutorial/index.html">tutorial</a>.</p>
<p>We begin by creating a <code>Cargo.toml</code> file and specifying the necessary dependencies:</p>
<pre><code class="language-toml">[package]
name = &quot;calc&quot;
version = &quot;0.0.1&quot;
authors = [&quot;&lt;authors&gt;&quot;]

[[bin]]
doc = false
name = &quot;calc&quot;

[build-dependencies]
lrlex = { path=&quot;&lt;path to lrlex&gt;&quot; }
lrpar = { path=&quot;&lt;path to lrpar&gt;&quot; }

[dependencies]
cfgrammar = { path=&quot;&lt;path to cfgrammar&gt;&quot; }
lrlex = { path=&quot;&lt;path to lrlex&gt;&quot; }
lrpar = { path=&quot;&lt;path to lrpar&gt;&quot; }
</code></pre>
<p>In the root of the project we create a file <code>build.rs</code>, which processes our
lexer and grammar files. Here we can choose whether we want to generate a
default parse tree, or use grammar actions instead:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate lrlex;
extern crate lrpar;

use lrlex::LexerBuilder;
use lrpar::{CTParserBuilder, ActionKind};

fn main() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
    let lex_rule_ids_map = CTParserBuilder::new().action_kind(ActionKind::CustomAction).process_file_in_src(&quot;calc.y&quot;)?;
    LexerBuilder::new()
        .rule_ids_map(lex_rule_ids_map)
        .process_file_in_src(&quot;calc.l&quot;)?;
    Ok(())
}
</code></pre></pre>
<p>In this example we are using <code>CustomAction</code> to write a simple calculator
grammar that calculates user input as it is being parsed. We define lexing and
grammar rules as follows, and store them in <code>calc.l</code> and <code>calc.y</code> respectively:</p>
<p>calc.l:</p>
<pre><code>%%
[0-9]+ &quot;INT&quot;
\+ &quot;PLUS&quot;
\* &quot;MUL&quot;
\( &quot;LBRACK&quot;
\) &quot;RBRACK&quot;
[\t ]+ ;
</code></pre>
<p>calc.y:</p>
<pre><code>%start Expr
// Define the type that is to be returned by the actions. Can also be an enum.
%type MYTYPE
%%
Expr: Term 'PLUS' Expr { add($1, $3) }
    | Term { $1 }
    ;

Term: Factor 'MUL' Term { mul ($1, $3) }
    | Factor { $1 }
    ;

Factor: 'LBRACK' Expr 'RBRACK' { $2 }
      | 'INT' { int($1) }
      ;
%%

type MYTYPE = u64;

// The following functions are in scope for all the grammar actions above.

fn int(s: &amp;str) -&gt; MYTYPE {
    match s.parse::&lt;u64&gt;() {
        Ok(val) =&gt; val as MYTYPE,
    Err(_) =&gt; unreachable!()
    }
}

fn add(arg1: u64, arg2: u64) -&gt; u64 {
    arg1 + arg2
}

fn mul(arg1: u64, arg2: u64) -&gt; u64 {
    arg1 * arg2
}
</code></pre>
<p>Now we can create the main function for our program which uses the parser
generated in <code>build.rs</code>. When run, this program will take some user input,
parse it according to the grammar, and return the result of the grammar
actions:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate lrpar;

use lrpar::{LexParseError, Lexer};

// Using `lrlex_mod!` brings the lexer for `calc.l` into scope.
lrlex_mod!(calc_l);
// Using `lrpar_mod!` brings the lexer for `calc.l` into scope.
lrpar_mod!(calc_y);

fn main() {
    // We need to get a `LexerDef` for the `calc` language in order that we can lex input.
    let lexerdef = calc_l::lexerdef();
    let stdin = io::stdin();
    loop {
        print!(&quot;&gt;&gt;&gt; &quot;);
        io::stdout().flush().ok();
        match stdin.lock().lines().next() {
            Some(Ok(ref l)) =&gt; {
                if l.trim().is_empty() {
                    continue;
                }
                // Now we create a lexer with the `lexer` method with which we can lex an input.
                let mut lexer = lexerdef.lexer(l);
                // Pass the lexer to the parser and lex and parse the input.
                match calc_y::parse(&amp;mut lexer) {
                    // Success! We parsed the input.
                    Ok(pt) =&gt; println!(&quot;Result: {}&quot;, pt),
                    // We weren't able to fully lex the input, so all we can do is tell the user
                    // at what index the lexer gave up at.
                    Err(LexParseError::LexError(e)) =&gt; {
                        println!(&quot;Lexing error at column {:?}&quot;, e.idx)
                    }
                    // Parsing failed, so we simply report the error to the user.
                    Err(LexParseError::ParseError(_, errs)) =&gt; {
                        // One or more errors were detected during parsing.
                        for e in errs {
                            let (line, col) = lexer.line_and_col(e.lexeme()).unwrap();
                            assert_eq!(line, 1);
                            println!(&quot;Parsing error at column {}.&quot;, col);
                        }
                    }
                }
            }
            _ =&gt; break
        }
    }
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
